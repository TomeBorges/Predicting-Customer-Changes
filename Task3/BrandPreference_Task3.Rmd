---
title: "Task 3: Multiple Regression in R"
output: html_notebook
---

This notebook contains the answers to Task 3:Multiple Regression in R.


```{r - Initial imports}
library(readr)
library(caret)
library(ggplot2)
library(dplyr)
library(corrplot)
```

```{r - Read the dataset from memory}
train_df<- read.csv("existingproductattributes2017.csv")#Clients who included their favorite computer brand in the questionaire answers
test_df<- read.csv("newproductattributes2017.csv") #Clients that did not favorite computer brand
train_df
test_df
```

These are the two datasets to be used for this task. 
It's worth noting that the column "volume" in the test_df has been filled with zeroes (as default). Therefore this column is meaningless as it is and should not be used directly.

*Understand the data:*

```{r - Getting to know the training data}
#print("List your attributes within your data set.")
#attributes(train_df)  # Too long
print("Prints the min, max, mean, median, and quartiles of each attribute.")
summary(train_df)
print("Displays the structure of your data set.")
str(train_df)
print("Names your attributes within your data set.")
names(train_df)
#print("Will print out the instances within that particular column in your data set.")
#train_df$salary # Too long
#train_df$age  # Too long
```

```{r - Compare if the testing data is similar to the training data (except for the volume column)}
print("Prints the min, max, mean, median, and quartiles of each attribute.")
summary(test_df)
print("Displays the structure of your data set.")
str(test_df)
print("Names your attributes within your data set.")
names(test_df)
```
The summary for each column is quite similar between these two dataframes. In fact, the minimum and maximum value are exactly the same for all columns except for the "volume" (which is comprehensible). The value for 1st and 3rd quartile as well as the mean and median is also pretty similar.

```{r - Do column types in train dataset coincide with their data? Or do I need to convert data types?}

sapply(train_df, typeof)
sapply(train_df, typeof) == sapply(test_df, typeof)

```
The column types coincide, but the variable ProductType is of character type. Therefore, I shall dummify this column into a binary One hot encoding with caret. The remaining columns are of numerical type so no further adjustments needed here. 

```{r - Dummify the data:}

#Convert categorical columns into factors to indicate that these columns contain a limited number of unique values.
length(table(train_df$ProductType))


# Rewrite the train_df with the dummy variables:
newDataFrame <- dummyVars(" ~ .", data = train_df)
train_df <- data.frame(predict(newDataFrame, newdata = train_df))
train_df

```
The column ProductType has 12 possible values.
As we previously had 18 columns in total, after dummifying the data both datasets will contain (18-1(removal of original column)+12=) 29 columns, which is what we have.

```{r - Replicate same conversions to test_df:}

# Rewrite the train_df with the dummy variables:
newDataFrame <- dummyVars(" ~ .", data = test_df)
test_df <- data.frame(predict(newDataFrame, newdata = test_df))
test_df
```
The same 29 columns are verified here.

```{r - Are there missing values?}
any(is.na(train_df))
any(is.na(test_df))

```
The train_df has null values. Investigate:

```{r - Which columns have null values:}
names(which(colSums(is.na(train_df)) > 0))
train_df$BestSellersRank
```
As can be seen above the column BestSellersRank in the train_df has got quite a few Null values. According to the plan of attack I should just ignore the variables with nulls. (Otherwise, I would address these nulls by replacing them with whatever one should do when correcting ranking variables. Out of the top of my head, I would quite possibly use the median as replacement value. This way, the replaced nulls would be pretty neutral when looking at this variable as a whole)


```{r - Address missing values of both datasets by simply eliminating the column:}
train_df$BestSellersRank <- NULL
train_df

test_df$BestSellersRank <- NULL
test_df
```



*Exploratory Data Analysis*

Following the Plan of Attack, I will now calculate the correlations, but before I will reconfirm that all variables are of numerical type in both datasets:

```{r}
str(train_df)
str(test_df)
```
Yes they are!


```{r - Correlations}
corrData_train <- cor(train_df)
#corrData_train

corrData_test <- cor(test_df)
#corrData_test

```

Instead of printing the matrixes I will simply plot a correlation heat map as it presents the data in a more readable and concise way.

NOTE: Instead of posting the two correlation plots in the R markdown below I saved them as pictures to be seen with higher quality.


```{r - Correlation plot for the train dataset:}
png(file="corr_train.png", res=300, width=4500, height=4500)
corrplot(corrData_train, method ='number')
dev.off() #Avoid overwritting png image above
```

```{r - Correlation plot for the test dataset:}
png(file="corr_test.png", res=300, width=4500, height=4500)
corrplot(corrData_test, method ='number')
dev.off()#Avoid overwritting png image above
```
The correlations from both datasets are quite similar. The biggest difference is that the Volume has no correlation in the test dataframe because this column is invariable (looking at the formula there is a division by zero in this case resulting in an undefined number).

All x'N'StarReviews variables are significantly positively correlated among each other. Interestingly, the further the classification the lower the correlation is. This fact makes sense because these variables are a simple count. I would argue that the high correlation among these features can be owed to their common nature, a causation relation seems to be unlikely among these variables.
The variables associated with product dimensions are also notably positively correlated. Once again because of the nature of these features, it makes sense that these are quite correlated. Packaging dimension and weight follow certain rules.

Other than these, there are a few relevant individual situations mostly of positive correlations such as the case of ProductType Laptop with Price or ProductType Printer with Profit Margin in the testing dataset and Volume with the star reviews (particularly with 5 star review which has a correlation of 1!) or Extended Warranty with Profit margin.

Finally, looking exclusively to the correlations of the volume in the train dataset, it is visible that the products with any StarReview or PositiveServiceReview have a much higher volume (Review associated features are possibily be the most relevant features towards predicting the volume of sales). Another interesting outtake from this correlation matrix is that Game Consoles have a much correlation with volume than any other prduct type, meaning that these have higher volumes.
Variables such as Profit Margin or any of the product dimensions have a correlation closer to zero with Volume. These variables may not be relevant towards predicting this target.

*Creating testing and training sets with caret:*
```{r}

inTrain <- createDataPartition(y = train_df$Volume,
            ## the outcome data are needed
            p = .75,# The percentage of data in the training set should be 75%
            list = FALSE)
#The output is a set of integers for the rows of Sonar that belong in the training set.

training <- train_df[ inTrain,] #TrainSet will contain the selected indices.
testing <- train_df[-inTrain,] #TestSet will contain only the remaining rows that have not been selected.

nrow(training)
nrow(testing)

```

**Caret Model 1: Create a linear model that uses volume as its dependent variable:**

```{r}
#Write trainSet in the data parameter instead of on each variable just to improve readability
LinearModel<- lm(Volume ~ PositiveServiceReview, training) #The analysis goal is to predict the Volume of a product using the most informative singular feature (which appears to be PositveServiceReview).
summary(LinearModel)

predictions <- LinearModel %>% predict(testing)

RMSE(predictions, testing$Volume)
R2(predictions, testing$Volume)
```
Using only 1 variable and a linear regression the best results I obtained in forecasting the Volume was with the PositiveServiceReview feature. The RMSE is 558 and the R-squared is 0.37, which are two extremely high values revealing that this model is not effective and is not robust or accurate enough to be utilized with confidence.

Linear models, generalized linear models, and nonlinear models are examples of parametric regression models because we know the function that describes the relationship between the response and explanatory variables.
This dataset is small and the data does not seem to follow the distributional requirements of parametric methods as can be seen below, the data is highly skewed and many features are categorical, not numerical:

```{r - Histogram of all variables in the dataset}
hist(train_df$ProductTypeAccessories)
hist(train_df$ProductTypeDisplay)
hist(train_df$ProductTypeExtendedWarranty)
hist(train_df$ProductTypeGameConsole)
hist(train_df$ProductTypeLaptop)
hist(train_df$ProductTypeNetbook)
hist(train_df$ProductTypePC)
hist(train_df$ProductTypePrinter)
hist(train_df$ProductTypePrinterSupplies)
hist(train_df$ProductTypeSmartphone)
hist(train_df$ProductTypeSoftware)
hist(train_df$ProductTypeTablet)
hist(train_df$ProductNum)
hist(train_df$Price)
hist(train_df$x5StarReviews)
hist(train_df$x4StarReviews)
hist(train_df$x3StarReviews)
hist(train_df$x2StarReviews)
hist(train_df$x1StarReviews)
hist(train_df$PositiveServiceReview)
hist(train_df$NegativeServiceReview)
hist(train_df$Recommendproduct)
hist(train_df$ShippingWeight)
hist(train_df$ProductDepth)
hist(train_df$ProductWidth)
hist(train_df$ProductHeight)
hist(train_df$ProfitMargin)
hist(train_df$Volume)
```

Note: Below I created a multiple linear regression (which is not what the PoA asked for, therefore I will not go into much detail other than a brief comment.

```{r}
#Write trainSet in the data parameter instead of on each variable just to improve readability
MLRModel<- lm(Volume ~ ., training) #Creation of a Multiple Linear Regression taking into account all variables (except obviously for the dependent one) as features to forecast the Volume;
summary(MLRModel)
```

The multiple linear regression obtained incredible results which is doubtful. Something could be wrong above. If all is correct then the dependent variable is extremely predictable looking into the independent ones. I will confirm this in the following models.


*Let's dive into some non-parametric machine learning models now:*
```{r - Set seed & define training and test datasets}
set.seed(107)

#Train and test data sets have been previously created.

```

```{r - Load missing libraries for the modeling part of this notebook}
library(gbm)
library(Rcpp)
```



**Caret Model 2: Support Vector Machine (SVM)**

**Caret Model 3: Random Forest (RF)**

**Caret Model 4: Gradient Boosting (GB)**


```{r - GBM 10 fold cross validation}
gbmfitControl <- trainControl(method = "repeatedcv", number = 10, repeats = 1)
```

Because this dataset is slightly unbalanced, I will attempt to train according to the kappa metric instead of accuracy.
(Practically, Cohen’s kappa removes the possibility of the classifier and a random guess agreeing and measures the number of predictions it makes that cannot be explained by a random guess. Furthermore, Cohen’s kappa tries to correct the evaluation bias by taking into account the correct classification by a random guess.)

```{r - Train Gradient Boost Classification model}
# tuneLenght = 1 (trains with 1 mtry value for RandomForest)
gbmFit1 <- train(brand~., #y, target
                 data = training, #X, features
                 metric = 'Kappa', #Metric applied
                 method = "gbm", #ML algorithm
                 trControl=gbmfitControl, #Apply CV to the training
                 tuneLength = 10, # Number of levels for each tuning parameters that should be generated
                 verbose = FALSE)

gbmFit1
```

As asked, in this part we are supposed to train a model using Stochastic Gradient Boosting, GBM, on the training set with 10-fold cross-validation and an Automatic Tuning Grid, which is what is coded above.

Train function chooses the model with the largest performance value (or smallest, for mean squared error in regression models), therefore there is no need to select the best iteration of the models.

```{r -  Ascertain how the model prioritized each feature in the GBM training}
varImp(gbmFit1)
```

As predicted the salary variable is the most relevant in predicting the target variable. Age comes in a close second place. The remaining variables have a really low relative impact when forecasting the target.

```{r - Make predictions based on GBM trained model and calculate basic metrics (with PostResample)}
pred_GBM <- predict(gbmFit1, newdata = testing)

Prob_pred_GBM <- predict(gbmFit1, newdata = testing, type = "prob")

postResample(pred_GBM, testing$brand)
```

This model provides an accuracy of ~94% which is pretty high.
The Kappa or Cohen's Kappa is at ~86% which is quite impressive since this metric is normalized at the baseline of random chance on our dataset.
This dataset has a slightly unbalanced target, therefore the Kappa value is quite different from the accuracy value.
It's worth adding that if the model was trained to optimise the accuracy, the metrics accuracy and Kappa obtained would be respectively: 0.932498 0.856289. Therefore optimising this model to the metric "Kappa" is a much better alternative for this dataset as it provided better results in both metrics!


```{r - Further metrics with confusion matrix}
confusionMatrix(data = pred_GBM, 
                reference = testing$brand, 
                positive = "1")
```
The confusion matrix is quite solid, the auxiliary statistical metrics derived, seem to confirm so. Below, I commented how each of the metrics calculated from the confusion matrix support that the model has a good performance overall:
- _Accuracy_: This is the most intuitive performance measure and it is simply a ratio of correctly predicted observation to the total observations ((TN+TP)/Total). Forecasting correctly ~94% of the test observations is pretty good;
- _95% CI_: The 95% confidence interval estimates that the accuracy falls within an interval with low variation within a high performance.
- _No information rate_: The "no-information rate" is the largest proportion of the observed classes. The test set contains 62% class 1 (Sony) and only (100-62)=38% class 0 (Acer);
- _P-Value_: A p-value, or probability value, is a number describing how likely it is that your data would have occurred by random chance (i.e. that the null hypothesis is true). In this case the p-value is clearly smaller than the the reference of 0.05, meaning that the p-value is statistically significant and the null hypothesis may be rejected;

- _Kappa_: The Kappa has been explained and commented above;

- _Mcnemar's Test P-Value_: In terms of comparing two binary classification algorithms, the test is commenting on whether the two models disagree in the same way (or not). It is not commenting on whether one model is more or less accurate or error prone than another. This is clear when we look at how the statistic is calculated. In this case we have fed a confusion matrix to the function and not a contingency table (comparing simply the number of correct vs. incorrect observations while discounting the classes);

- _Sensitivity_: Proportion of those who correctly received a positive result (class 1 - Sony) on this test out of those who actually have a positive result (TP/(TP+FN)). The value obtained for this metric is ~95% which is alright;
- _Specificity_: Proportion of those who correctly received a negative result (class 0 - Acer) on this test out of those who actually have a negative result (TN/(FP+TN)). The percentage of correctly predicted Sony is higher than Acer;
- _Pos Pred Value_: Proportion of positive results that are true positive (TP/(TP+FP));
- _Neg Pred Value_: Proportion of negative results that are true negative (TN/(TN+FN)). This model has a higher accuracy in forecasting class 1 (Sony) relatively to class 0;
- _Prevalence_:  Measure of the frequency of a condition in a population at a particular point in time ((TP+FN)/Total). In this case the condition measured is the positives. As can be seen this dataset is slightly unbalanced;
- _Detection Rate_: Here the detection rate is defined as the fraction of observations who are in fact positive and are called positive by the model (TP/Total). Fortunately, this percentage is similar to the prevalence meaning that the model captured the class skewness of this dataset. If the value was too different the False Negatives would be hindering the model's performance;
- _Detection Prevalence_: This is defined as the number of predicted positive events (both true positive and false positive) divided by the total number of predictions ((TP+FP)/Total). This value is similar to what was obtained in the prevalence metric, this indicates that the amount of false negatives is simillar to the false positives when considering the whole test dataset;
- _Balanced Accuracy_: Balanced accuracy attempts to account for the imbalance in classes ((TPR+TNR)/2 = (Sensitivity+Specificity)/2). The balanced accuracy is slightly lower than the accuracy. Nonetheless, this metric is at 92%, thus this model clearly captured the data unbalance and is not just supposing that the most frequent class is the correct one (in this case the balanced accuracy would be 50% and the accuracy would coincide with the proportion of the most frequent class relatively to the less occuring one).

```{r - Calculate two class summary for binary GBM model}
temp_pred_GB = factor(ifelse(pred_GBM == 1, "Y", "N"))
temp_obs_GB = factor(ifelse(testing$brand == 1, "Y", "N"))

twoClassSummary(data = data.frame(obs = temp_obs_GB, pred = temp_pred_GB, Y = Prob_pred_GBM$'1', N = Prob_pred_GBM$'0'), lev = levels(temp_pred_GB))
#For some reason, this function does not seem to provide ROC results if a binary numerical labeling is used, I had to convert '1' into 'Y' and '0' into 'N' to obtain valid results

mnLogLoss(data = data.frame(obs = temp_obs_GB, pred = temp_pred_GB, Y = Prob_pred_GBM$'1', N = Prob_pred_GBM$'0'), lev = levels(temp_pred_GB))
```
The area under the ROC curve is close to 1 meaning that the classifier is far better than a random classifier (AUC of 0.5). In fact, the AUC is close to 1, a perfect classifier. The value of the specificity and specificity seem to have swapped among themselves (the values calculated in the function above are the correct ones), thus, I will not comment these values.
- _Log Loss_: Log-loss is indicative of how close the prediction probability is to the corresponding actual/true value (0 or 1 in case of binary classification). The more the predicted probability diverges from the actual value, the higher is the log-loss value. In the case of the LogLoss metric, one usual "well-known" metric is to say that 0.693 is the non-informative value. This figure is obtained by predicting p = 0.5 for any class of a binary problem. This is valid only for balanced binary problems. 
Because we have obtained a Log Loss of 0.218, much lower than 0.693, we can afirm that this model is clearly better than random picking and has captured the problem.

**Caret Model 2: Use Random Forest with 10-fold cross-validation to predict nominal data and manually tune 5 different mtry values**

```{r - RF 10 fold cross validation}
rffitControl <- trainControl(method = "repeatedcv", number = 10, repeats = 1)
```

In this task we have to manually tune 5 different values for the "mtry" parameter.The "mtry" is the number of variables randomly sampled as candidates at each split. Note that the default values are different for classification (sqrt(p) where p is number of variables in x) and regression (p/3). In this case we are foing a classification thus the default value is sqrt(36) which is 6. I started by centering center the grid search in the default value and search equidistantly on both sides (upper and lower) of this value. However, I verified that the optimal performance falls in a higher value of "mtry".

Similarly to the model trained above, I will optimise towards the Kappa metric.

```{r - Create grid for manual training of mtry & train Random Forest Regression model}
rfGrid <- expand.grid(mtry=c(6,9,10,11,12))

# tuneLenght = 1 (trains with 1 mtry value for RandomForest)
rfFit1 <- train(brand~., #y, target
                data = training,#X, features
                metric = 'Kappa', #Metric applied
                method = "rf", #ML algorithm
                trControl=rffitControl, #Apply manual grid search to the training
                tuneGrid=rfGrid, #Grid parameters
                verbose = FALSE)

rfFit1
```

As asked, in this part we are supposed to train a model using Random Forest, RF, on the training set with 10-fold cross-validation and an manual Tuning Grid, which is what is coded above.

Train function chooses the model with the largest performance value (or smallest, for mean squared error in regression models), therefore there is no need to select the best iteration of the models.


```{r -  Ascertain how the model prioritized each feature in the RF training}
varImp(rfFit1)
```

Similarly to the previous model, salary once again is the most relevant feature in predicting the target variable. Again, age comes in a second place. Credit has a much higher relative importance, however, it is clearly less important than the two top features. The remaining variables have a really low relative impact when forecasting the target.

```{r - Make predictions based on RF trained model and calculate basic metrics (wuth PostResample)}
pred_RF <- predict(rfFit1, newdata = testing)

Prob_pred_RF <- predict(rfFit1, newdata = testing, type = "prob")

postResample(pred_RF, testing$brand)

```

This model provides an accuracy of ~94% which is pretty high.
This dataset has a slightly imbalanced target, therefore the Kappa value is quite different from the accuracy value.
The Kappa or Cohen's Kappa is at ~86% which is quite impressive since this metric is normalized at the baseline of random chance on our dataset.


```{r - Further metrics of RF with confusion matrix}
confusionMatrix(data = pred_RF, 
                reference = testing$brand, 
                positive = "1")
```
Similarly to the previous model, the confusion matrix is quite solid, the auxiliary statistical metrics derived, seem to confirm so. The two models created in this exercise are quite similar in theory and in the provided results. Therefore, instead of repeating the comment section I have written for the previous model, I will just say that those comments can be applied to this model and move on to the next part (Additionaly, this model is slightly inferior relatively to the GBM thus I chose to focus in the other).


```{r - Calculate two class summary for binary RF model}
temp_pred_RF = factor(ifelse(pred_RF == 1, "Y", "N"))
temp_obs_RF = factor(ifelse(testing$brand == 1, "Y", "N"))

twoClassSummary(data = data.frame(obs = temp_obs_RF, pred = temp_pred_RF, Y = Prob_pred_RF$'1', N = Prob_pred_RF$'0'), lev = levels(temp_pred_RF))
#For some reason, this function does not seem to provide ROC results if a binary numerical labeling is used, I had to convert '1' into 'Y' and '0' into 'N' to obtain valid results


mnLogLoss(data = data.frame(obs = temp_obs_RF, pred = temp_pred_RF, Y = Prob_pred_RF$'1', N = Prob_pred_RF$'0'), lev = levels(temp_pred_RF))
```

The area under the ROC curve is close to 1 meaning that the classifier is far better than a random classifier (AUC of 0.5). In fact, the AUC is close to 1, a perfect classifier. The value of the specificity and specificity seem to have swapped among themselves (the values calculated in the function above are the correct ones), thus, I will not comment these values.
- _Log Loss_: Log-loss is indicative of how close the prediction probability is to the corresponding actual/true value (0 or 1 in case of binary classification). The more the predicted probability diverges from the actual value, the higher is the log-loss value. In the case of the LogLoss metric, one usual "well-known" metric is to say that 0.693 is the non-informative value. This figure is obtained by predicting p = 0.5 for any class of a binary problem. This is valid only for balanced binary problems. 
Because we have obtained a Log Loss of 0.218, much lower than 0.693, we can afirm that this model is clearly better than random picking and has captured the problem.




*Compare the results from two models:*
```{r - Compare results}
results <- resamples(list(GBMAut=gbmFit1, RFMan=rfFit1))

summary(results)

bwplot(results)
```
Looking at the table and boxplot of the chunk above it seems that both algorithms have a good performance in forecasting the target of this problem. However, the Stochastic Gradient Boost seems to provide a slightly better performing model as the interquartile range for both the accuracy and kappa falls is located at a higher value.


*Forecast testing dataset with the best performing model (GBM)*


```{r - Make dummy variable for caret}
OneHot_test_df <- data.frame(model.matrix( ~ ., data=test_df))
OneHot_test_df <- subset(OneHot_test_df, select=-c(brand1)) # Remove target column
```


```{r - Calculate the prediction with the best model trained above:}
prediction<-predict(gbmFit1,OneHot_test_df)
```


```{r - Post resampling for accuracy and Kappa of model in test dataset:}

postResample(prediction, test_df$brand)

```

Not surprisingly the Accuracy and Kappa are absolutely awful. As mentioned before, the values for the target column of the test dataset seem to have been filled arbitrarily and should not be payed any attention. Therefore, we cannot measure the actual accuracy or any other metric in the test dataset, as there is no true column to compare the forecast against. We must believe that the population from the test dataset behaves similarly to the train dataset and that both datasets have been picked randomly (otherwise the population could have suffer sample selection bias)

```{r - Summary of prediction:}
summary(prediction)
```

```{r - Preferred computer brand comparison in the train, test and both datasets:}
#Computer Brand
barplot(table(train_df$brand),names.arg = c('Acer','Sony'))

barplot(table(prediction),names.arg = c('Acer','Sony'))

TotalTarget <- data.frame(TestTrain = c(train_df$brand, prediction))
barplot(table(TotalTarget),names.arg = c('Acer','Sony'))

```


```{r - Plot chart to compare proportion of computer brands between Train and predictions}
# create a dataset
Dataset <- c("Train Dataset", "Predictions","Train Dataset", "Predictions")
Brand <- c("Sony","Sony","Acer","Acer")
PercentageCount <- c(table(train_df$brand)["0"],
           table(train_df$brand)["1"],
           table(prediction)["0"],
           table(prediction)["1"])
data <- data.frame(Dataset,Brand,Count)

# Stacked + percent
ggplot(data, aes(fill=Brand, y=PercentageCount, x=Dataset)) + 
    geom_bar(position="fill", stat="identity") +
    ylab("Percentage Count")
```
As can be seen above, the proportion of preferred computer brand is the same for both datasets, this supports the thesis that both datasets refer to a similarlly behaving population (if no the same) and that the model trained in the first dataset can be applied on the second.

```{r - Add column with predictions and save into .tab file}

test_df$prediction <- prediction
test_df
write_tsv(test_df,"SurveyIncomplete_WithPreds.tab")
```


In conclusion, Blackwell's customers typically prefer Sony as their computer brand comparatively to Acer, and this can be forecast with a high accuracy.